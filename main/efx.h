/*
  Q Light Controller
  efx.h
  
  Copyright (c) Heikki Junnila
  
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  Version 2 as published by the Free Software Foundation.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details. The license is
  in the file "COPYING".
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef EFX_H
#define EFX_H

#include <QList>

#include "common/qlctypes.h"

#include "efxfixture.h"
#include "function.h"

class QDomDocument;
class QDomElement;
class QPolygon;
class QString;
class Fixture;

#define KXMLQLCEFXPropagationMode "PropagationMode"
#define KXMLQLCEFXPropagationModeParallel "Parallel"
#define KXMLQLCEFXPropagationModeSerial "Serial"
#define KXMLQLCEFXAlgorithm "Algorithm"
#define KXMLQLCEFXWidth "Width"
#define KXMLQLCEFXHeight "Height"
#define KXMLQLCEFXRotation "Rotation"
#define KXMLQLCEFXAxis "Axis"
#define KXMLQLCEFXOffset "Offset"
#define KXMLQLCEFXFrequency "Frequency"
#define KXMLQLCEFXPhase "Phase"
#define KXMLQLCEFXChannel "Channel"
#define KXMLQLCEFXX "X"
#define KXMLQLCEFXY "Y"
#define KXMLQLCEFXStartScene "StartScene"
#define KXMLQLCEFXStopScene "StopScene"

/**
 * An EFX (effects) function that is used to create
 * more complex automation especially for moving lights
 */
class EFX : public Function
{
	Q_OBJECT

	friend class EFXFixture;

	/*********************************************************************
	 * Initialization
	 *********************************************************************/
public:
	EFX(QObject* parent);
	~EFX();

	/**
	 * Copy function contents from another function
	 *
	 * @param efx EFX function from which to copy contents to this function
	 * @param to The new parent fixture for this function
	 */
	bool copyFrom(EFX* efx);

	/*********************************************************************
	 * Preview
	 *********************************************************************/
public:
	/**
	 * Set a pointer to a point array for updating the
	 * changes when editing the function.
	 *
	 * @note Call this function with NULL after editing is finished!
	 *
	 * @param array The array to save the preview points to
	 */
	void setPreviewPointArray(QPolygon* array);

	/**
	 * Updates the preview points (if necessary)
	 */
	void updatePreview();

protected:
	/**
	 * The point array which holds a preview of the pattern
	 * generated by this EFX function when run. This should be
	 * used only from the EFX Editor and set to NULL after finished
	 * editing.
	 */
	QPolygon* m_previewPointArray;

	/*********************************************************************
	 * Algorithm
	 *********************************************************************/
public:
	/** Get the supported algorithms in a string list */
	static QStringList algorithmList();

	/** Get the current algorithm */
	QString algorithm();

	/** Set the current algorithm */
	void setAlgorithm(QString algorithm);

protected:
	/** Current algorithm used by the EFX */
	QString m_algorithm;

	/*********************************************************************
	 * Width
	 *********************************************************************/
public:
	/**
	 * Set the pattern width
	 *
	 * @param width Pattern width (0-255)
	 */
	void setWidth(int width);

	/**
	 * Get the pattern width
	 *
	 * @return Pattern width (0-255)
	 */
	int width();

protected:
	/**
	 * Pattern width, see \ref setWidth
	 */
	float m_width;

	/*********************************************************************
	 * Height
	 *********************************************************************/
public:
	/**
	 * Set the pattern height
	 *
	 * @param height Pattern height (0-255)
	 */
	void setHeight(int height);

	/**
	 * Get the pattern height
	 *
	 * @return Pattern height (0-255)
	 */
	int height();

protected:
	/**
	 * Pattern height, see \ref setHeight
	 */
	float m_height;

	/*********************************************************************
	 * Rotation
	 *********************************************************************/
public:
	/**
	 * Set the pattern rotation
	 *
	 * @param rot Pattern rotation (0-359)
	 */
	void setRotation(int rot);

	/**
	 * Get the pattern rotation
	 *
	 * @return Pattern rotation (0-359)
	 */
	int rotation();

protected:
	/**
	 * Pattern rotation, see \ref setRotation
	 */
	int m_rotation;
  
	/*********************************************************************
	 * Offset
	 *********************************************************************/
public:
	/**
	 * Set the pattern offset on the X-axis
	 *
	 * @param offset Pattern offset (0-255; 127 is middle)
	 */
	void setXOffset(int offset);

	/**
	 * Get the pattern offset on the X-axis
	 *
	 * @return Pattern offset (0-255; 127 is middle)
	 */
	int xOffset();

	/**
	 * Set the pattern offset on the Y-axis
	 *
	 * @param offset Pattern offset (0-255; 127 is middle)
	 */
	void setYOffset(int offset);

	/**
	 * Get the pattern offset on the Y-axis
	 *
	 * @return Pattern offset (0-255; 127 is middle)
	 */
	int yOffset();

protected:
	/**
	 * Pattern X offset, see \ref setXOffset
	 */
	float m_xOffset;

	/**
	 * Pattern Y offset, see \ref setXOffset
	 */
	float m_yOffset;
  
	/*********************************************************************
	 * Frequency
	 *********************************************************************/
public:
	/**
	 * Set the lissajous pattern frequency  on the X-axis
	 *
	 * @param freq Pattern frequency (0-255)
	 */
	void setXFrequency(int freq);

	/**
	 * Get the lissajous pattern frequency on the X-axis
	 *
	 * @return Pattern offset (0-255)
	 */
	int xFrequency();

	/**
	 * Set the lissajous pattern frequency  on the Y-axis
	 *
	 * @param freq Pattern frequency (0-255)
	 */
	void setYFrequency(int freq);

	/**
	 * Get the lissajous pattern frequency on the Y-axis
	 *
	 * @return Pattern offset (0-255)
	 */
	int yFrequency();

	/**
	 * Returns true when lissajous has been selected
	 */
	bool isFrequencyEnabled();

protected:
	/**
	 * Lissajous pattern X frequency, see \ref setXFrequency
	 */
	float m_xFrequency;

	/**
	 * Lissajous pattern Y frequency, see \ref setYFrequency
	 */
	float m_yFrequency;

	/*********************************************************************
	 * Phase
	 *********************************************************************/
public:
	/**
	 * Set the lissajous pattern phase on the X-axis
	 *
	 * @param phase Pattern phase (0-255)
	 */
	void setXPhase(int phase);

	/**
	 * Get the lissajous pattern phase on the X-axis
	 *
	 * @return Pattern phase (0-255)
	 */
	int xPhase();

	/**
	 * Set the lissajous pattern phase on the Y-axis
	 *
	 * @param phase Pattern phase (0-255)
	 */
	void setYPhase(int phase);

	/**
	 * Get the lissajous pattern phase on the Y-axis
	 *
	 * @return Pattern phase (0-255)
	 */
	int yPhase();

	/**
	 * Returns true when lissajous has been selected
	 */
	bool isPhaseEnabled();

protected:
	/**
	 * Lissajous pattern X phase, see \ref setXPhase
	 */
	float m_xPhase;

	/**
	 * Lissajous pattern Y phase, see \ref setYPhase
	 */
	float m_yPhase;

	/*********************************************************************
	 * Fixtures
	 *********************************************************************/
public:
	/**
	 * Parallel mode means that all fixtures move exactly like others.
	 * Serial mode means that fixtures start moving one after the other,
	 * a bit delayed, creating a more dynamic effect.
	 */
	enum PropagationMode { Parallel, Serial };

public:
	/** Add a fixture to this EFX */
	void addFixture(t_fixture_id fxi_id);

	/** Remove the designated fixture from this EFX */
	void removeFixture(t_fixture_id fxi_id);

	/** Raise a fixture in the serial order to an earlier position */
	void raiseFixture(t_fixture_id fxi_id);

	/** Lower a fixture in the serial order to a later position */
	void lowerFixture(t_fixture_id fxi_id);

	/** Set a particular fixture's direction */
	void setFixtureDirection(t_fixture_id fxi_id, Function::Direction dir);

	/** Get a particular fixture's direction */
	Function::Direction fixtureDirection(t_fixture_id fxi_id);

	/** Get a list of fixtures taking part in this EFX */
	QList <t_fixture_id> fixtures() const;

public slots:
	/** Slot that captures Doc::fixtureRemoved signals */
	void slotFixtureRemoved(t_fixture_id fxi_id);

protected:
	QList <EFXFixture> m_fixtures;

	/*********************************************************************
	 * Fixture propagation mode
	 *********************************************************************/
public:
	/** Set the EFX's fixture propagation mode (see the enum above) */
	void setPropagationMode(PropagationMode mode);
	
	/** Get the EFX's fixture propagation mode */
	PropagationMode propagationMode() const { return m_propagationMode; }
	
	/** Convert the propagation mode setting to a string */
	static QString propagationModeToString(PropagationMode mode);

	/** Convert a string to a propagation mode setting */
	static PropagationMode stringToPropagationMode(QString str);

protected:
	PropagationMode m_propagationMode;

	/*********************************************************************
	 * Start & Stop Scenes
	 *********************************************************************/
public:
	/** Set the start scene */
	void setStartScene(t_function_id id);
  
	/** Get the start scene */
	t_function_id startScene();
  
	/** Set start scene enabled status */
	void setStartSceneEnabled(bool set);

	/** Get start scene enabled status */
	bool startSceneEnabled();

	/** Set the stop scene */
	void setStopScene(t_function_id id);
  
	/** Get the stop scene */
	t_function_id stopScene();
  
	/** Set stop scene enabled status */
	void setStopSceneEnabled(bool set);

	/** Get stop scene enabled status */
	bool stopSceneEnabled();

protected:
	/** Start (initialisation) scene */
	t_function_id m_startSceneID;
	bool m_startSceneEnabled;

	/** Stop (de-initialisation) scene */
	t_function_id m_stopSceneID;
	bool m_stopSceneEnabled;
    
	/*********************************************************************
	 * Load & Save
	 *********************************************************************/
public:
	/**
	 * Save the function's contents to an XML document
	 *
	 * @param doc The QDomDocument to save to
	 * @param wksp_root The workspace root XML element
	 */
	bool saveXML(QDomDocument* doc, QDomElement* wksp_root);

	/**
	 * Load the function's contents from an XML document
	 *
	 * @param doc The QDomDocument to load from
	 * @param root The EFX root XML element
	 */
	bool loadXML(QDomDocument* doc, QDomElement* root);

protected:
	/**
	 * Load an axis' contents from an XML document
	 *
	 * @param doc The QDomDocument to load from
	 * @param root An EFX Axis root XML element
	 */
	bool loadXMLAxis(QDomDocument* doc, QDomElement* root);

	/*********************************************************************
	 * Bus
	 *********************************************************************/
public slots:
	/**
	 * This is called by buses for each function when the
	 * bus value is changed.
	 * 
	 * @param id ID of the bus that has changed its value
	 * @param value Bus' new value
	 */
	void slotBusValueChanged(t_bus_id id, t_bus_value value);

	/*********************************************************************
	 * Point calculation functions
	 *********************************************************************/
protected:
	/**
	 * Function pointer for the point calculation function.
	 * This pointer is replaced by the appropriate function pointer
	 * depending on the chosen algorithm.
	 *
	 * @param efx The EFX function using this
	 * @param iterator Step number
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 */
	void (*pointFunc) (EFX* efx, float iterator, float* x, float* y);

	/**
	 * Calculate a single point in a circle based on
	 * the value of iterator (which is basically a step number)
	 *
	 * @note This is a static function
	 *
	 * @param efx The EFX function using this
	 * @param iterator Step number
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 */
	static void circlePoint(EFX* efx, float iterator, float* x, float* y);

	/**
	 * Calculate a single point in a eight pattern based on
	 * the value of iterator (which is basically a step number)
	 *
	 * @note This is a static function
	 *
	 * @param efx The EFX function using this
	 * @param iterator Step number
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 */
	static void eightPoint(EFX* efx, float iterator, float* x, float* y);

	/**
	 * Calculate a single point in a line pattern based on
	 * the value of iterator (which is basically a step number)
	 *
	 * @note This is a static function
	 *
	 * @param efx The EFX function using this
	 * @param iterator Step number
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 */
	static void linePoint(EFX* efx, float iterator, float* x, float* y);

	/**
	 * Calculate a single point in a triangle pattern based on
	 * the value of iterator (which is basically a step number)
	 *
	 * @note This is a static function
	 *
	 * @param efx The EFX function using this
	 * @param iterator Step number
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 */
	static void trianglePoint(EFX* efx, float iterator, float* x, float* y);

	/**
	 * Calculate a single point in a diamond pattern based on
	 * the value of iterator (which is basically a step number)
	 *
	 * @note This is a static function
	 *
	 * @param efx The EFX function using this
	 * @param iterator Step number
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 */
	static void diamondPoint(EFX* efx, float iterator, float* x, float* y);

	/**
	 * Calculate a single point in a lissajous pattern based on
	 * the value of iterator (which is basically a step number)
	 *
	 * @note This is a static function
	 *
	 * @param efx The EFX function using this
	 * @param iterator Step number
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 */
	static void lissajousPoint(EFX* efx, float iterator, float* x, float* y);

	/**
	 * Rotate a point of the pattern by rot degrees and scale the point
	 * within w/h and xOff/yOff.
	 *
	 * @param x Holds the calculated X coordinate
	 * @param y Holds the calculated Y coordinate
	 * @param w The width to scale to
	 * @param h The height to scale to
	 * @param xOff X offset of the pattern
	 * @param yOff Y offset of the pattern
	 * @param rotation Degrees to rotate
	 */
	static void rotateAndScale(float *x, float *y, float w, float h,
				   float xOff, float yOff, float rotation);

	/*********************************************************************
	 * Running
	 *********************************************************************/
public:
	/**
	 * Prepare this function for running. This is called when
	 * the user sets the mode to Operate. Basically allocates everything
	 * that is needed to run the function.
	 */
	void arm();

	/**
	 * Free all run-time allocations. This is called respectively when
	 * the user sets the mode back to Design.
	 */
	void disarm();

	/**
	 * Stop this EFX immediately (as soon as possible)
	 */
	void stop();

protected:
	/**
	 * The worker thread that takes care of filling the function's
	 * buffer with event data
	 */
	void run();

protected:
	/**
	 * Flag used to stop the EFX manually
	 */
	bool m_stopped;

	/**
	 * The size of one step derived from m_cycleDuration. If m_cycleDuration
	 * is 64, then this is 1/64.
	 */
	float m_stepSize;

	/**
	 * Channel data that is written to the event buffer
	 */
	t_buffer_data* m_channelData;

	/**
	 * Actual number of channels inside m_channelData
	 */
	int m_channels;

	/**
	 * Run-time pan & tilt channels and their values
	 */
	QList <EFXFixture> m_runTimeFixtures;
};

#endif
